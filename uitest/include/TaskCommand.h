// Generated by gencpp from file tocabi_controller/TaskCommand.msg
// DO NOT EDIT!


#ifndef TOCABI_CONTROLLER_MESSAGE_TASKCOMMAND_H
#define TOCABI_CONTROLLER_MESSAGE_TASKCOMMAND_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace tocabi_controller
{
template <class ContainerAllocator>
struct TaskCommand_
{
  typedef TaskCommand_<ContainerAllocator> Type;

  TaskCommand_()
    : ratio(0.0)
    , height(0.0)
    , pelv_pitch(0.0)
    , roll(0.0)
    , pitch(0.0)
    , yaw(0.0)
    , solver(0)
    , contactredis(0)
    , left(false)
    , right(false)
    , time(0.0)
    , mode(0)
    , l_x(0.0)
    , l_y(0.0)
    , l_z(0.0)
    , l_roll(0.0)
    , l_pitch(0.0)
    , l_yaw(0.0)
    , r_x(0.0)
    , r_y(0.0)
    , r_z(0.0)
    , r_roll(0.0)
    , r_pitch(0.0)
    , r_yaw(0.0)
    , walking_enable(0)
    , pattern(0)
    , pattern2(0)
    , ik_mode(0)
    , dob(false)
    , imu(false)
    , first_foot_step(0)
    , x(0.0)
    , y(0.0)
    , z(0.0)
    , walking_height(0.0)
    , theta(0.0)
    , step_length_x(0.0)
    , step_length_y(0.0)
    , customTaskGain(false)
    , acc_p(0.0)
    , pos_p(0.0)
    , pos_d(0.0)
    , ang_p(0.0)
    , ang_d(0.0)  {
    }
  TaskCommand_(const ContainerAllocator& _alloc)
    : ratio(0.0)
    , height(0.0)
    , pelv_pitch(0.0)
    , roll(0.0)
    , pitch(0.0)
    , yaw(0.0)
    , solver(0)
    , contactredis(0)
    , left(false)
    , right(false)
    , time(0.0)
    , mode(0)
    , l_x(0.0)
    , l_y(0.0)
    , l_z(0.0)
    , l_roll(0.0)
    , l_pitch(0.0)
    , l_yaw(0.0)
    , r_x(0.0)
    , r_y(0.0)
    , r_z(0.0)
    , r_roll(0.0)
    , r_pitch(0.0)
    , r_yaw(0.0)
    , walking_enable(0)
    , pattern(0)
    , pattern2(0)
    , ik_mode(0)
    , dob(false)
    , imu(false)
    , first_foot_step(0)
    , x(0.0)
    , y(0.0)
    , z(0.0)
    , walking_height(0.0)
    , theta(0.0)
    , step_length_x(0.0)
    , step_length_y(0.0)
    , customTaskGain(false)
    , acc_p(0.0)
    , pos_p(0.0)
    , pos_d(0.0)
    , ang_p(0.0)
    , ang_d(0.0)  {
  (void)_alloc;
    }



   typedef double _ratio_type;
  _ratio_type ratio;

   typedef double _height_type;
  _height_type height;

   typedef double _pelv_pitch_type;
  _pelv_pitch_type pelv_pitch;

   typedef double _roll_type;
  _roll_type roll;

   typedef double _pitch_type;
  _pitch_type pitch;

   typedef double _yaw_type;
  _yaw_type yaw;

   typedef uint32_t _solver_type;
  _solver_type solver;

   typedef uint32_t _contactredis_type;
  _contactredis_type contactredis;

   typedef uint8_t _left_type;
  _left_type left;

   typedef uint8_t _right_type;
  _right_type right;

   typedef double _time_type;
  _time_type time;

   typedef int32_t _mode_type;
  _mode_type mode;

   typedef double _l_x_type;
  _l_x_type l_x;

   typedef double _l_y_type;
  _l_y_type l_y;

   typedef double _l_z_type;
  _l_z_type l_z;

   typedef double _l_roll_type;
  _l_roll_type l_roll;

   typedef double _l_pitch_type;
  _l_pitch_type l_pitch;

   typedef double _l_yaw_type;
  _l_yaw_type l_yaw;

   typedef double _r_x_type;
  _r_x_type r_x;

   typedef double _r_y_type;
  _r_y_type r_y;

   typedef double _r_z_type;
  _r_z_type r_z;

   typedef double _r_roll_type;
  _r_roll_type r_roll;

   typedef double _r_pitch_type;
  _r_pitch_type r_pitch;

   typedef double _r_yaw_type;
  _r_yaw_type r_yaw;

   typedef uint32_t _walking_enable_type;
  _walking_enable_type walking_enable;

   typedef uint32_t _pattern_type;
  _pattern_type pattern;

   typedef uint32_t _pattern2_type;
  _pattern2_type pattern2;

   typedef uint32_t _ik_mode_type;
  _ik_mode_type ik_mode;

   typedef uint8_t _dob_type;
  _dob_type dob;

   typedef uint8_t _imu_type;
  _imu_type imu;

   typedef uint32_t _first_foot_step_type;
  _first_foot_step_type first_foot_step;

   typedef float _x_type;
  _x_type x;

   typedef float _y_type;
  _y_type y;

   typedef float _z_type;
  _z_type z;

   typedef float _walking_height_type;
  _walking_height_type walking_height;

   typedef float _theta_type;
  _theta_type theta;

   typedef float _step_length_x_type;
  _step_length_x_type step_length_x;

   typedef float _step_length_y_type;
  _step_length_y_type step_length_y;

   typedef uint8_t _customTaskGain_type;
  _customTaskGain_type customTaskGain;

   typedef float _acc_p_type;
  _acc_p_type acc_p;

   typedef float _pos_p_type;
  _pos_p_type pos_p;

   typedef float _pos_d_type;
  _pos_d_type pos_d;

   typedef float _ang_p_type;
  _ang_p_type ang_p;

   typedef float _ang_d_type;
  _ang_d_type ang_d;





  typedef boost::shared_ptr< ::tocabi_controller::TaskCommand_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::tocabi_controller::TaskCommand_<ContainerAllocator> const> ConstPtr;

}; // struct TaskCommand_

typedef ::tocabi_controller::TaskCommand_<std::allocator<void> > TaskCommand;

typedef boost::shared_ptr< ::tocabi_controller::TaskCommand > TaskCommandPtr;
typedef boost::shared_ptr< ::tocabi_controller::TaskCommand const> TaskCommandConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::tocabi_controller::TaskCommand_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::tocabi_controller::TaskCommand_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::tocabi_controller::TaskCommand_<ContainerAllocator1> & lhs, const ::tocabi_controller::TaskCommand_<ContainerAllocator2> & rhs)
{
  return lhs.ratio == rhs.ratio &&
    lhs.height == rhs.height &&
    lhs.pelv_pitch == rhs.pelv_pitch &&
    lhs.roll == rhs.roll &&
    lhs.pitch == rhs.pitch &&
    lhs.yaw == rhs.yaw &&
    lhs.solver == rhs.solver &&
    lhs.contactredis == rhs.contactredis &&
    lhs.left == rhs.left &&
    lhs.right == rhs.right &&
    lhs.time == rhs.time &&
    lhs.mode == rhs.mode &&
    lhs.l_x == rhs.l_x &&
    lhs.l_y == rhs.l_y &&
    lhs.l_z == rhs.l_z &&
    lhs.l_roll == rhs.l_roll &&
    lhs.l_pitch == rhs.l_pitch &&
    lhs.l_yaw == rhs.l_yaw &&
    lhs.r_x == rhs.r_x &&
    lhs.r_y == rhs.r_y &&
    lhs.r_z == rhs.r_z &&
    lhs.r_roll == rhs.r_roll &&
    lhs.r_pitch == rhs.r_pitch &&
    lhs.r_yaw == rhs.r_yaw &&
    lhs.walking_enable == rhs.walking_enable &&
    lhs.pattern == rhs.pattern &&
    lhs.pattern2 == rhs.pattern2 &&
    lhs.ik_mode == rhs.ik_mode &&
    lhs.dob == rhs.dob &&
    lhs.imu == rhs.imu &&
    lhs.first_foot_step == rhs.first_foot_step &&
    lhs.x == rhs.x &&
    lhs.y == rhs.y &&
    lhs.z == rhs.z &&
    lhs.walking_height == rhs.walking_height &&
    lhs.theta == rhs.theta &&
    lhs.step_length_x == rhs.step_length_x &&
    lhs.step_length_y == rhs.step_length_y &&
    lhs.customTaskGain == rhs.customTaskGain &&
    lhs.acc_p == rhs.acc_p &&
    lhs.pos_p == rhs.pos_p &&
    lhs.pos_d == rhs.pos_d &&
    lhs.ang_p == rhs.ang_p &&
    lhs.ang_d == rhs.ang_d;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::tocabi_controller::TaskCommand_<ContainerAllocator1> & lhs, const ::tocabi_controller::TaskCommand_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace tocabi_controller

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::tocabi_controller::TaskCommand_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::tocabi_controller::TaskCommand_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::tocabi_controller::TaskCommand_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::tocabi_controller::TaskCommand_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::tocabi_controller::TaskCommand_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::tocabi_controller::TaskCommand_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::tocabi_controller::TaskCommand_<ContainerAllocator> >
{
  static const char* value()
  {
    return "b8ccd7b97d48c879f3a749882e59fb48";
  }

  static const char* value(const ::tocabi_controller::TaskCommand_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xb8ccd7b97d48c879ULL;
  static const uint64_t static_value2 = 0xf3a749882e59fb48ULL;
};

template<class ContainerAllocator>
struct DataType< ::tocabi_controller::TaskCommand_<ContainerAllocator> >
{
  static const char* value()
  {
    return "tocabi_controller/TaskCommand";
  }

  static const char* value(const ::tocabi_controller::TaskCommand_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::tocabi_controller::TaskCommand_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# CoM/Pelvis Control\n"
"float64 ratio # left foot 0 ----- 1 right foot\n"
"float64 height\n"
"\n"
"float64 pelv_pitch\n"
"float64 roll\n"
"float64 pitch\n"
"float64 yaw\n"
"\n"
"uint32 solver\n"
"uint32 contactredis\n"
"\n"
"# Contact \n"
"bool left\n"
"bool right\n"
"\n"
"# Control Duration And Mode\n"
"float64 time\n"
"int32 mode\n"
"\n"
"# Left/Right Arm Control\n"
"float64 l_x\n"
"float64 l_y\n"
"float64 l_z\n"
"float64 l_roll\n"
"float64 l_pitch\n"
"float64 l_yaw\n"
"\n"
"float64 r_x\n"
"float64 r_y\n"
"float64 r_z\n"
"float64 r_roll\n"
"float64 r_pitch\n"
"float64 r_yaw\n"
"\n"
"# Walking\n"
"uint32 walking_enable\n"
"uint32 pattern\n"
"uint32 pattern2\n"
"uint32 ik_mode\n"
"bool dob\n"
"bool imu\n"
"uint32 first_foot_step\n"
"float32 x\n"
"float32 y\n"
"float32 z\n"
"float32 walking_height\n"
"float32 theta\n"
"float32 step_length_x\n"
"float32 step_length_y\n"
"\n"
"# TaskGain\n"
"bool customTaskGain\n"
"float32 acc_p\n"
"float32 pos_p\n"
"float32 pos_d\n"
"float32 ang_p\n"
"float32 ang_d\n"
;
  }

  static const char* value(const ::tocabi_controller::TaskCommand_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::tocabi_controller::TaskCommand_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.ratio);
      stream.next(m.height);
      stream.next(m.pelv_pitch);
      stream.next(m.roll);
      stream.next(m.pitch);
      stream.next(m.yaw);
      stream.next(m.solver);
      stream.next(m.contactredis);
      stream.next(m.left);
      stream.next(m.right);
      stream.next(m.time);
      stream.next(m.mode);
      stream.next(m.l_x);
      stream.next(m.l_y);
      stream.next(m.l_z);
      stream.next(m.l_roll);
      stream.next(m.l_pitch);
      stream.next(m.l_yaw);
      stream.next(m.r_x);
      stream.next(m.r_y);
      stream.next(m.r_z);
      stream.next(m.r_roll);
      stream.next(m.r_pitch);
      stream.next(m.r_yaw);
      stream.next(m.walking_enable);
      stream.next(m.pattern);
      stream.next(m.pattern2);
      stream.next(m.ik_mode);
      stream.next(m.dob);
      stream.next(m.imu);
      stream.next(m.first_foot_step);
      stream.next(m.x);
      stream.next(m.y);
      stream.next(m.z);
      stream.next(m.walking_height);
      stream.next(m.theta);
      stream.next(m.step_length_x);
      stream.next(m.step_length_y);
      stream.next(m.customTaskGain);
      stream.next(m.acc_p);
      stream.next(m.pos_p);
      stream.next(m.pos_d);
      stream.next(m.ang_p);
      stream.next(m.ang_d);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct TaskCommand_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::tocabi_controller::TaskCommand_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::tocabi_controller::TaskCommand_<ContainerAllocator>& v)
  {
    s << indent << "ratio: ";
    Printer<double>::stream(s, indent + "  ", v.ratio);
    s << indent << "height: ";
    Printer<double>::stream(s, indent + "  ", v.height);
    s << indent << "pelv_pitch: ";
    Printer<double>::stream(s, indent + "  ", v.pelv_pitch);
    s << indent << "roll: ";
    Printer<double>::stream(s, indent + "  ", v.roll);
    s << indent << "pitch: ";
    Printer<double>::stream(s, indent + "  ", v.pitch);
    s << indent << "yaw: ";
    Printer<double>::stream(s, indent + "  ", v.yaw);
    s << indent << "solver: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.solver);
    s << indent << "contactredis: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.contactredis);
    s << indent << "left: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.left);
    s << indent << "right: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.right);
    s << indent << "time: ";
    Printer<double>::stream(s, indent + "  ", v.time);
    s << indent << "mode: ";
    Printer<int32_t>::stream(s, indent + "  ", v.mode);
    s << indent << "l_x: ";
    Printer<double>::stream(s, indent + "  ", v.l_x);
    s << indent << "l_y: ";
    Printer<double>::stream(s, indent + "  ", v.l_y);
    s << indent << "l_z: ";
    Printer<double>::stream(s, indent + "  ", v.l_z);
    s << indent << "l_roll: ";
    Printer<double>::stream(s, indent + "  ", v.l_roll);
    s << indent << "l_pitch: ";
    Printer<double>::stream(s, indent + "  ", v.l_pitch);
    s << indent << "l_yaw: ";
    Printer<double>::stream(s, indent + "  ", v.l_yaw);
    s << indent << "r_x: ";
    Printer<double>::stream(s, indent + "  ", v.r_x);
    s << indent << "r_y: ";
    Printer<double>::stream(s, indent + "  ", v.r_y);
    s << indent << "r_z: ";
    Printer<double>::stream(s, indent + "  ", v.r_z);
    s << indent << "r_roll: ";
    Printer<double>::stream(s, indent + "  ", v.r_roll);
    s << indent << "r_pitch: ";
    Printer<double>::stream(s, indent + "  ", v.r_pitch);
    s << indent << "r_yaw: ";
    Printer<double>::stream(s, indent + "  ", v.r_yaw);
    s << indent << "walking_enable: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.walking_enable);
    s << indent << "pattern: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.pattern);
    s << indent << "pattern2: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.pattern2);
    s << indent << "ik_mode: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.ik_mode);
    s << indent << "dob: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.dob);
    s << indent << "imu: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.imu);
    s << indent << "first_foot_step: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.first_foot_step);
    s << indent << "x: ";
    Printer<float>::stream(s, indent + "  ", v.x);
    s << indent << "y: ";
    Printer<float>::stream(s, indent + "  ", v.y);
    s << indent << "z: ";
    Printer<float>::stream(s, indent + "  ", v.z);
    s << indent << "walking_height: ";
    Printer<float>::stream(s, indent + "  ", v.walking_height);
    s << indent << "theta: ";
    Printer<float>::stream(s, indent + "  ", v.theta);
    s << indent << "step_length_x: ";
    Printer<float>::stream(s, indent + "  ", v.step_length_x);
    s << indent << "step_length_y: ";
    Printer<float>::stream(s, indent + "  ", v.step_length_y);
    s << indent << "customTaskGain: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.customTaskGain);
    s << indent << "acc_p: ";
    Printer<float>::stream(s, indent + "  ", v.acc_p);
    s << indent << "pos_p: ";
    Printer<float>::stream(s, indent + "  ", v.pos_p);
    s << indent << "pos_d: ";
    Printer<float>::stream(s, indent + "  ", v.pos_d);
    s << indent << "ang_p: ";
    Printer<float>::stream(s, indent + "  ", v.ang_p);
    s << indent << "ang_d: ";
    Printer<float>::stream(s, indent + "  ", v.ang_d);
  }
};

} // namespace message_operations
} // namespace ros

#endif // TOCABI_CONTROLLER_MESSAGE_TASKCOMMAND_H
